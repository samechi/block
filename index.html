<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>簡易版テトリス</title>
  <style>
    canvas { background: #111; display: block; margin: 20px auto; }
    body { text-align: center; color: white; font-family: sans-serif; background: #222; }
  </style>
</head>
<body>
  <h2>簡易版テトリス</h2>
  <canvas id="game" width="300" height="600"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const ROWS = 20, COLS = 10, BLOCK = 30;

    const board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));

    const tetrominoes = [
      [[1,1,1,1]], // I
      [[1,1],[1,1]], // O
      [[0,1,0],[1,1,1]], // T
      [[1,0,0],[1,1,1]], // L
      [[0,0,1],[1,1,1]], // J
      [[1,1,0],[0,1,1]], // S
      [[0,1,1],[1,1,0]]  // Z
    ];

    let current = randomTetromino();
    let x = 3, y = 0;

    function randomTetromino() {
      return tetrominoes[Math.floor(Math.random() * tetrominoes.length)];
    }

    function drawBlock(x, y, color="cyan") {
      ctx.fillStyle = color;
      ctx.fillRect(x * BLOCK, y * BLOCK, BLOCK-1, BLOCK-1);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 盤面
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c]) drawBlock(c, r, "yellow");
        }
      }

      // 落下中のブロック
      for (let r = 0; r < current.length; r++) {
        for (let c = 0; c < current[r].length; c++) {
          if (current[r][c]) drawBlock(x + c, y + r, "cyan");
        }
      }
    }

    function collide(nx, ny, shape) {
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (shape[r][c]) {
            let newX = nx + c;
            let newY = ny + r;
            if (newX < 0 || newX >= COLS || newY >= ROWS || board[newY]?.[newX]) {
              return true;
            }
          }
        }
      }
      return false;
    }

    function merge() {
      for (let r = 0; r < current.length; r++) {
        for (let c = 0; c < current[r].length; c++) {
          if (current[r][c]) board[y + r][x + c] = 1;
        }
      }
    }

    function clearLines() {
      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(v => v)) {
          board.splice(r, 1);
          board.unshift(Array(COLS).fill(0));
          r++;
        }
      }
    }

    function rotate(shape) {
      const N = shape.length;
      const M = shape[0].length;
      let rotated = Array.from({ length: M }, () => Array(N).fill(0));
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < M; c++) {
          rotated[c][N - 1 - r] = shape[r][c]; // 時計回り
        }
      }
      return rotated;
    }

    function drop() {
      if (!collide(x, y + 1, current)) {
        y++;
      } else {
        merge();
        clearLines();
        current = randomTetromino();
        x = 3; y = 0;
        if (collide(x, y, current)) {
          alert("ゲームオーバー");
          for (let r = 0; r < ROWS; r++) board[r].fill(0);
        }
      }
    }

    setInterval(() => {
      drop();
      draw();
    }, 500);

    // PCキー操作
    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft" && !collide(x-1, y, current)) x--;
      if (e.key === "ArrowRight" && !collide(x+1, y, current)) x++;
      if (e.key === "ArrowDown" && !collide(x, y+1, current)) y++;
      if (e.key === "q" || e.key === "Q") {
        let rotated = rotate(current);
        if (!collide(x, y, rotated)) current = rotated;
      }
      draw();
    });

    // ゲームパッド対応
    let buttons = {};
    function updateGamepad() {
      const gp = navigator.getGamepads()[0];
      if (gp) {
        if (gp.axes[0] < -0.5 && !buttons.left) { if (!collide(x-1, y, current)) x--; buttons.left=true; }
        else if (gp.axes[0] > 0.5 && !buttons.right) { if (!collide(x+1, y, current)) x++; buttons.right=true; }
        else if (Math.abs(gp.axes[0]) < 0.2) { buttons.left=false; buttons.right=false; }

        if (gp.buttons[0].pressed && !buttons.a) { // Aボタンで回転
          let rotated = rotate(current);
          if (!collide(x, y, rotated)) current = rotated;
          buttons.a = true;
        } else if (!gp.buttons[0].pressed) {
          buttons.a = false;
        }
      }
      requestAnimationFrame(updateGamepad);
    }
    updateGamepad();
  </script>
</body>
</html>
